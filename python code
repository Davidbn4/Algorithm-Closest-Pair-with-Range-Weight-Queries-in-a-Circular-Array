from math import inf
from typing import List, Tuple

# Helper: Safe modulo for circular array
def safe_mod(i: int, n: int) -> int:
    return ((i % n) + n) % n

# Helper: Squared Euclidean distance (avoid sqrt for performance)
def squared_distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:
    x1, y1 = p1
    x2, y2 = p2
    return (x2 - x1) ** 2 + (y2 - y1) ** 2

# Helper: Create prefix sum array for weights
def create_prefix_sum(weights: List[float]) -> List[float]:
    prefix = [0] * (len(weights) + 1)
    for i in range(len(weights)):
        prefix[i + 1] = prefix[i] + weights[i]
    return prefix

# Helper: Range sum query using prefix sum (supports circular ranges)
def range_sum(prefix: List[float], left: int, right: int, n: int) -> float:
    left = safe_mod(left, n)
    right = safe_mod(right, n)
    if right >= left:
        return prefix[right + 1] - prefix[left]
    else:
        # Handle circular range: sum from left to end + start to right
        return prefix[n] - prefix[left] + prefix[right + 1]

# Main Algorithm: Find closest pair and handle range queries
def closest_pair_and_range_queries(
    points: List[Tuple[float, float]],
    weights: List[float],
    queries: List[Tuple[int, int]]
) -> Tuple[Tuple[int, int, float], List[float]]:
    n = len(points)
    if n < 2:
        return (-1, -1, inf), []

    # Brute-force closest pair search
    min_dist = inf
    closest_pair = (-1, -1)
    for i in range(n):
        for j in range(i + 1, n):
            dist = squared_distance(points[i], points[j])
            if dist < min_dist:
                min_dist = dist
                closest_pair = (i, j)

    # Precompute prefix sum for weights
    prefix_sum = create_prefix_sum(weights)

    # Process range sum queries
    query_results = []
    for left, right in queries:
        query_results.append(range_sum(prefix_sum, left, right, n))

    # Optional: Assign Fibonacci-based weights to closest pair (e.g., for scoring)
    def fib_iterative(n):
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a

    i, j = closest_pair
    fib_score = fib_iterative(abs(i - j) % n) if i != j else 0

    # Return tuple (index1, index2, squared_distance), [range_sum_results]
    return (closest_pair[0], closest_pair[1], min_dist), query_results

# Example Usage
if __name__ == "__main__":
    points = [(0, 0), (1, 1), (2, 0), (1, -1)]  # 2D points
    weights = [10, 20, 30, 40]  # Weights for each point
    queries = [(0, 2), (1, 3), (3, 1)]  # Range sum queries

    (closest_i, closest_j, min_dist), range_sums = closest_pair_and_range_queries(points, weights, queries)

    print(f"Closest pair indices: ({closest_i}, {closest_j}), Squared Distance: {min_dist}")
    print(f"Range sum queries: {range_sums}")
